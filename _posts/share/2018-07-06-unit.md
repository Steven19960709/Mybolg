---
layout: post
title: 集合
date: 2018-07-06
tags: [share]
---

對於任何的JavaScript程序來說，對數據的結構化組合和訪問都是一個關鍵部分。這個語言從一開始開始到現在，創建數據結構的主要機制都是數組和對象。

那麼在ES6中，已經把一部分性能最優，使用率最高的數據結構抽象作為原生組件添加到JavaScript中。

## TypedArray

帶類型的數組是為了使用類數組語義（索引訪問等）結構化訪問二進制數據。名稱中的“type（類型）”是指代一組位序列的“視圖”，本質上就是一個映射。例如：可以把這些位序列映射為8位有符號整形數組，也可以映射為16號有符號整形數組。

    let buf = new ArrayBuffer(32);
    buf.byteLength // 32

buf就是一個二進制buffer，長度為32字節（256位），預先初始化全部為0.一個buffer本身除了查看它的byteLength屬性之外，並不支持請他交互。

之後，我們可以在這個數組buffer智商，放置一個哦“視圖”，這個視圖以類型數組的形式存在。

    let arr = new Unit16Array(buf);
    arr.length // 16

arr在這個256為buf上映射的一個16位無符號整型的類型數組，就相當於我們得到了16個元素。

### 大小端

arr的映射是按照運行JavaScript的平台的大小端設置進行的。如果二進制數據的構造是居於某個大小端配置，而解釋平台的大小端配置卻與之相反，那麼就是一個問題了。

所謂的大小端就是多字節數字中的低字節位於這個數字字節表示的右側還是左側。例如，十進制3085，利用16位表示，不管大小端如何配置，那麼都會被表示為0000110000001101（0c0d）。

但是如果利用兩個8位數表示數字3085，那麼大小端設置就會明顯影響到它在內存中的存儲表示：

- 0000110000001101 / 0c0d (big side)
- 0000110100001100 / 0d0c (small side)

如果接收到一個來自於小段系統的表示3085的位序列000110100001100，而在大端系統為其建立視圖，得到的值將是3340（十進制）或者0d0c（十六進制）

目前web最常用的是小端表示。對於使用大端表示，我們可以使用以下方法檢測：

    let litteEndian = (function () {
        let buffer = new ArrayBuffer(2);
        new DataView(buffer).setUnt16(0, 256, true);
        return new Int16Array(buffer)[0] === 256;
    })()

### 帶類數組構造器

ES6提供了下面這些帶類數組構造器：

- IntArray(8位有符號整形),Uint8Array（8位無符號整形）
- Int16Array（16位有符號整形），Unit16Array（16位無符號整型）
- Float32Array（32浮點數）
- Float64Array（64位浮點數）

TypedArray中的元素是限制在聲明的位數大小中的。如果試圖個一個Unit8Array的某個元素賦值為大於8位的值，這個值就會被折回（wrap around）來適應其位寬。

## Map

對象是創建無序鍵/值對數據結構[也稱映射(map)]主要機制。但是，對象作為映射的主要缺點是不能使用非字符串值作為鍵。如果想使用維護平衡的非字符串數組和值可以這樣做：

    let keys = [], vals = [];
    let x = {
        id: 1
    }
    let y = {
        id: 2
    }
    keys.push(x);
    vals.push('foo');
    keys.push(y);
    vals.push("bar");

這樣顯得非常麻煩，我們利用ES6中新增的Map就可以解決這個問題。

    let m = new Map ();
    let x = { id: 0 };
    let y = { id: 1 };
    m.set(x, 'foo');
    m.set(y, 'bar');
    m.get( x );
    m.get( y );

這裡的唯一缺點就是不能使用“[]”,取而代之的是get和set。刪除元素就需要使用delete()方法。使用clear()清空整個map內容。要得到map的長度（也就是鍵的個數）可以使用size()，

具體關於map的介紹可以點擊[here](http://leunggabou.com/2018/04/23/set-map-1/)和[here](http://leunggabou.com/2017/09/17/ES6-18/)

### weakMap 

WeakMap是map的變體，二者的多數外部行為都是一樣的，區別在於內部內存分配的工作方式（特別是GC）

WeakMap只接受對象作為鍵值。這些對象都是被弱持有的，也就是說如果對象本設備垃圾回收的話，在WeakMap中的這個項目會被移除。WeakMap可以把信息與一個對象軟關聯前來。而在這個對象沒有完全控制權的時候，這個功能特別有用，例如DOM元素。如果作為映射的對象可以被刪除，并支持垃圾回收，那麼WeakMap就更是合適的選擇。

需要注意的是WeakMap只是弱持有它的鍵，而不是它的值。

### Set

Set是一個值的集合，其中的值是唯一的。具體可以點擊[here](http://leunggabou.com/2017/09/17/ES6-16/)

## 總結

ES6定義了幾個有用嗯嗯集合，這使得對數據的訪問更結構化且更加高效。

TypedArray提供了對二進制數據Buffer的各種整型類型“視圖”。對二進制數據的數組訪問使得運算更加容易表達和維護，從而更容易操縱視頻音頻、canvas數據等這樣的複雜數據。

Map是鍵值對，其中的鍵不只是對字符串/原生類型,也可以是對象。Set成員值唯一的列表。

WeakMap也是Map，其中的鍵（對象）是弱持有的，因此當它是對這個對象的最後一個引用的時候，GC可以回首這個項目。WeakSet也是Set，其中的值也是弱持有的也就是說如果其中的項目是對這個對象的最後一個引用的時候，GC也可以移除它。

那麼這部分內容就像講到這了，希望大家能有所收穫！