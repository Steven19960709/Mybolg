---
layout: post
title: vue FrameWork Live
date: 2018-10-14
tags: [vue]
---

### 状态管理

vue的状态管理为vuex，一定程度是受到redux的影响。本质是相同的，从原事件source event 映射到状态的改变，最后映射到UI上的变化。 通俗来说，点击按钮——应用状态改变——DOM改变。声明式的渲染已经处理好这个从状态到UI的映射这一块。那么状态管理这些代码库就是处理如何维护事件源到状态的变化的着一个过程。如何将这个映射的过程剥离出来，从视图组件中剥离出来，组织这部分代码，提高可维护性。

这些方案都是有问题是如何处理异步。redux是使用middleWare，但是不同的中间件，风格基本都是不一样，不易于维护。另外，就是组件的局部状态和全局的状态如何区分。全局状态和服务端数据之间，通用做法是把数据抓过来之后，直接放到全局状态里面。

### 路由

在大型的单页面应用中，路由用的比较多当react和vue只关注view层出现。组件和路由解耦。从组件到路由上进行思考，可以认为一个URL映射到组件树结构的一个过程。考虑状态触发还是组件触发，但是本质都是一个URL触发的。

路由会考虑一些问题：hash和history模式如何兼容，重定向，处理懒加载，处理跳转（包括用户的异步操作，实现一些钩子函数）等。react-router4最新的版本，推崇用组件本身做路由的思路，组件做功能性的组件。跟传统路由的最大区别为：去中心化，并不是把一个路由表写在一个地方，二十分散的写在各个组件，比较灵活，而且比较利于理解应用。但是，对跳转的管理会弱一点，直接使用组件的生命周期实现。但是，对于一些全局的状态则不利于管理，必须耦合在组件里面。

目前web路由都是将url映射到组件树。对于原生应用跟web有区别，它是一个新的页面盖在上面，如果退回一个页面，相当于把原来的一层拿掉。

### CSS

主流的 CSS 方案

- 跟 JS 完全解耦，靠预处理器和比如 BEM 这样的规范来保持可维护性，偏传统，js完全独立。
- CSS Modules，依然是 CSS，但是通过编译来避免 CSS 类名的全局冲突。例如vue的单文件组件，跟组件绑定在一起。

在spa应用中，传统的CSS写法不好维护。

- 各类 CSS-in-JS 方案，React 社区为代表，比较激进
- Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面），一种比较折中的方案

传统 css 的一些问题：

1. 作用域（利用scope，CSS Module都可以解决这个问题，CSS Module会有一定的性能开销，因为它需要用动态的Class绑定）
2. Critical CSS （
3. Atomic CSS：原子类，把尽可能多的规则都写成一个各类
4. 分发复用：跟普通的JavaScript模块一样发送到npm复用。webpack可以直接引用这里的npm包
5. 跨平台复用：通过把css parse 成JavaScript进行复用，动态的style绑定。

### 构建工具

以往前端不需要构建工具，现在多数需要下载各种包。随着技术升级，业务升级，工具也变得越来越复杂。

构建工具解决了一些问题：

- 任务的自动化
- 开发体验和效率（新的语言功能，语法糖，hot reload 等等）
- 部署相关的需求
- 编译时优化

grunp，glup，webpack等。grunp和glup比较少用了，主要是任务的自动执行这样的形式实现的。grunp基本就是跑任务的，glup就进入了流的概念。webpack就是目前的主流构建工具。

在资源部署这里，可以通过请求合并，文件打包。静态资源路径映射，小尺寸资源内联。[经典回答](https://www.zhihu.com/question/20790576)

跨平台渲染：渲染的时候与DOM进行解耦。把节点操作封装起来。针对每个平台渲染引擎进行一层封装。