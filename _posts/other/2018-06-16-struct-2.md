---
layout: post
title: 前端工程化——构建（2）
date: 2018-06-16
tags: [project]
---

## 模块化开发

模块化开发在前端方向具有动态特性，相比服务端语言的静态模块体系有一定差异。

严格来说，组件和模块是两个不同的概念。主要区别于颗粒度层面。简单来说，模块是一个百合，侧重的是属性的封装，重心在设计和开发阶段，不关注运行时逻辑；组件是一个可以独立部署的软件单元，面向的是运行时，侧重于产品的功能性。组件是一个黑盒，内部的逻辑是不可见的。模块可以理解为零件，如轮胎上的螺丝钉；而组建就是轮胎，具备某项完整的功能，是一个整体。

模块化是属于架构层面的概念，前端工程体系中的构建系统最重要功能之一就是支持模块化规范并能够将散列的模块构建为利于部署的整合文件，另外还需要兼顾性能优化。一个典型的场景是使用文件名hash指纹实现增量更新。

### 模块化开发优点

#### 避免变量冲突

JavaScript没有语言层面的命名空间概念，编写通用模块的普遍方案时将其暴露给全局作用域，这样方案最大的问题是无法有效的防止命名冲突。

#### 便于依赖管理

浏览器按照由上而下的顺序解析HTML文档，如果两个相邻的script标签，则必须等待前一个script内容加载并执行完毕之后才可以解析下一个script。这种机制导致对于存在依赖关系的js模块，被依赖方则必须在依赖需求方之前被加载。在前端模块化诞生之前，这样子的依赖处理普遍方法是通过控制script标签的顺序来实现。

依赖管理是模块化规范的核心特性之一，开发者遵循既定的规范进行各模块之间的源代码编写，构建工具按照模块化规范对代码进行解析，生成AST获取各模块化之间的依赖关系。HTML文档只需引入一个入口文件即可。

模块化解决了模块之间错综复杂的依赖管理问题，降低了开发难度和维护难度，可以让开发者专注于业务逻辑本身。


#### 利于性能优化

按需加载是进行web性能优化的铁律之一。虽然不使用模块化开发也能进行按需加载，但是配合模块化规范的以来管理功能可以让按需加载的模块更加易于管理。另外，使用模块化开发工具将同步的散列模块合并打包，可以减少客户端http请求，提高web应用的解析速度，减少服务器的并发压力。

#### 提高可维护性 利于代码复用

命名冲突和依赖管理问题最大的影响就是开发效率和维护效率，模块化解决了这两个经典问题，并且必然会带来开发和维护效率的提升。模块化的命名空间和砂箱机制，以及细粒度的模块划分，让单个模块更加易于维护和迭代，从而提升了整体项目的维护效率。

功能和业务弱耦合可以在一定应用场景下的以复用。代码复用的关键在于模块本身粒度以及逻辑的设计，很大程度依赖于开发者的抽象能力。

### 前端模块化发展史

1.CommonJS —— 面向浏览器之外的模块化规范

CommonJS最初的名字为ServeJS，从命名上能够看出他的定位并非是浏览器环境，而是针对与服务端或桌面应用开发等非浏览器环境下的JavaScript开发。2009年才被改名为CommonJS，随后被Nodejs采用为默认的模块化规范。但是只适合于Nodejs开发，并不适合浏览器环境，因为：

- 浏览器环境的前端资源不仅仅是JavaScript，还包括CSS，图片等，CommonJS无法处理js以外的资源。
- CommonJS所有模块均是同步阻塞加载，无法实现按需异步加载

于是就有了AMD/CMD机制了。

2、AMD与CMD规范并非完全一致，但核心功能是统一的。在CommonJS基础上，AMD、CMD规范扩展了以下功能。

- 可以处理JavaScript以外的资源
- 源码无需编译即可在浏览器环境下运行
- 按需异步加载，并行加载
- 插件系统

AC规范重点解决了浏览器对前端模块化的需求，两者在前几年前端生态圈中普及程度非常高。但三者仍有共同的缺点：

- 应用场景单一，模块无法跨环境运行。
- 构建工具㢥，开发者除了需要学习规范本身，还需要学习构建工具。CommonJS的Browserify，AMD的r.js，CMD的SPM。
- 不同规范的模块无法混合使用，模块可复用性不高

### ES6 Module 规范的静态模块体系

有了ES6 的module机制，上述三者基本退出历史舞台。ES6 module是一种静态模块体系，在最新的nodejs中，可以完全替代CommonJS。并且，module是语言层面的规范，与应用场景无关，但是目前浏览器仍未实现。