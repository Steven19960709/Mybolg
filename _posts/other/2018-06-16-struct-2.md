---
layout: post
title: 前端工程化——构建（2）
date: 2018-06-16
tags: [project]
---

## 模块化开发

模块化开发在前端方向具有动态特性，相比服务端语言的静态模块体系有一定差异。

严格来说，组件和模块是两个不同的概念。主要区别于颗粒度层面。简单来说，模块是一个百合，侧重的是属性的封装，重心在设计和开发阶段，不关注运行时逻辑；组件是一个可以独立部署的软件单元，面向的是运行时，侧重于产品的功能性。组件是一个黑盒，内部的逻辑是不可见的。模块可以理解为零件，如轮胎上的螺丝钉；而组建就是轮胎，具备某项完整的功能，是一个整体。

模块化是属于架构层面的概念，前端工程体系中的构建系统最重要功能之一就是支持模块化规范并能够将散列的模块构建为利于部署的整合文件，另外还需要兼顾性能优化。一个典型的场景是使用文件名hash指纹实现增量更新。

### 模块化开发优点

#### 避免变量冲突

JavaScript没有语言层面的命名空间概念，编写通用模块的普遍方案时将其暴露给全局作用域，这样方案最大的问题是无法有效的防止命名冲突。

#### 便于依赖管理

浏览器按照由上而下的顺序解析HTML文档，如果两个相邻的script标签，则必须等待前一个script内容加载并执行完毕之后才可以解析下一个script。这种机制导致对于存在依赖关系的js模块，被依赖方则必须在依赖需求方之前被加载。在前端模块化诞生之前，这样子的依赖处理普遍方法是通过控制script标签的顺序来实现。

依赖管理是模块化规范的核心特性之一，开发者遵循既定的规范进行各模块之间的源代码编写，构建工具按照模块化规范对代码进行解析，生成AST获取各模块化之间的依赖关系。HTML文档只需引入一个入口文件即可。

模块化解决了模块之间错综复杂的依赖管理问题，降低了开发难度和维护难度，可以让开发者专注于业务逻辑本身。


#### 利于性能优化

按需加载是进行web性能优化的铁律之一。虽然不使用模块化开发也能进行按需加载，但是配合模块化规范的以来管理功能可以让按需加载的模块更加易于管理。另外，使用模块化开发工具将同步的散列模块合并打包，可以减少客户端http请求，提高web应用的解析速度，减少服务器的并发压力。

#### 提高可维护性 利于代码复用

命名冲突和依赖管理问题最大的影响就是开发效率和维护效率，模块化解决了这两个经典问题，并且必然会带来开发和维护效率的提升。模块化的命名空间和砂箱机制，以及细粒度的模块划分，让单个模块更加易于维护和迭代，从而提升了整体项目的维护效率。

功能和业务弱耦合可以在一定应用场景下的以复用。代码复用的关键在于模块本身粒度以及逻辑的设计，很大程度依赖于开发者的抽象能力。

### 前端模块化发展史

1.CommonJS —— 面向浏览器之外的模块化规范

CommonJS最初的名字为ServeJS，从命名上能够看出他的定位并非是浏览器环境，而是针对与服务端或桌面应用开发等非浏览器环境下的JavaScript开发。2009年才被改名为CommonJS，随后被Nodejs采用为默认的模块化规范。但是只适合于Nodejs开发，并不适合浏览器环境，因为：

- 浏览器环境的前端资源不仅仅是JavaScript，还包括CSS，图片等，CommonJS无法处理js以外的资源。
- CommonJS所有模块均是同步阻塞加载，无法实现按需异步加载

于是就有了AMD/CMD机制了。

2、AMD与CMD规范并非完全一致，但核心功能是统一的。在CommonJS基础上，AMD、CMD规范扩展了以下功能。

- 可以处理JavaScript以外的资源
- 源码无需编译即可在浏览器环境下运行
- 按需异步加载，并行加载
- 插件系统

AC规范重点解决了浏览器对前端模块化的需求，两者在前几年前端生态圈中普及程度非常高。但三者仍有共同的缺点：

- 应用场景单一，模块无法跨环境运行。
- 构建工具㢥，开发者除了需要学习规范本身，还需要学习构建工具。CommonJS的Browserify，AMD的r.js，CMD的SPM。
- 不同规范的模块无法混合使用，模块可复用性不高

#### ES6 Module 规范的静态模块体系

有了ES6 的module机制，上述三者基本退出历史舞台。ES6 module是一种静态模块体系，在最新的nodejs中，可以完全替代CommonJS。并且，module是语言层面的规范，与应用场景无关，但是目前浏览器仍未实现，需要借助构建工具进行编译。

### 增量更新与缓存

合理利用缓存是Web缓存的必要手段，主要针对的是客户端浏览器的缓存策略，客户端的缓存可以分为以下两种。

- 利用本地存储，例如LocalStorage、SessionStorage等。
- 利用http缓存策略，其中又分为强制缓存和协商缓存

其中，对于本地存储的利用属于代码架构层面的优化措施，不属于前端工程体系范畴。http缓存需要服务器配合，例如Apache、Nginx等服务器软件可以为托尼盖资源设置不同的http缓存策略。增量更新是目前大部分团队采用的缓存更新方案。前端主要工作如下：

- 构建产出稳健hash指纹，只是增量更新的必要条件。
- 构建更新html文件对其他静态资源的引用url。

#### http缓存策略

之前提到过的强制缓存和协商缓存。两种缓存策略都会将资源换存到本地，强制缓存策略根据过期时间决定使用本地缓存还是请求新资源；而协商缓存每次都会发送请求，经过服务器进行对比后决定采用本地缓存还是新资源。具体有http首部信息决定（header）

1.Expires 和 max-age

Expires和max-age是强制缓存策略的关键信息，都是响应头的信息。Expires通过制定一个明确时间点作为缓存资源的过期时间，在此时间点之前，客户端将使用本地缓存的文件应答请求，而不会向服务器出实体请求（status=200）。Expires优点是可以在缓存过期时间内减少客户端的http请求，节省客户端处理数据时间，提高web应用的执行速度，而且也减少了服务器负载以及客户端网络资源的消耗。

    Expires: Wed, 23 Aug 2018 14:00:00 GMT

Expires有一个致命的缺陷，就是他所指定的时间点是一服务期为准的时间，但是客户端进行过奇葩短时是将本地时间与此时间点做对比，如果有误差，那么expires控制的缓存资源就会失效，客户端将会发送实体请求获取对应资源。

于是http1.1新增了cache-control头信息，来更精确地控制缓存。

max-age 指定的是缓存的时间跨度，而非缓存失效的时间点，不会受到客户端与服务器时间误差的影响。所以max-age比expires更精确地控制缓存，并且比expires有更高级的优先级。

流程：

<img src="http://os310ujuc.bkt.clouddn.com/nw1.png">

2.Etag和If-None-Match

ETag是服务器为资源分配的字符串形式唯一性标识，作为相应首部信息返回给浏览器。浏览器在Cache-control指定no-cache或者max-age和Expires均过期之后，将ETag值通过If-None-Match作为请求首部信息发给服务器。服务器收到请求之后，对比索请求资源的etag值是否改变，如果未改变将返回304 Not Modified，并且根据既定的缓存策略分配新的Cache-control信息；如果资源发生了改变，则会返回最新的资源以及重新分配的ETag值。

<img src="http://os310ujuc.bkt.clouddn.com/nw2.png">

如果强制浏览器使用协商缓存策略，需要将Cache-control首部信息设置为no-cache，这样便不会判断max-age和Expires过期时间，从而每次请求都会经过服务器对比。

### 覆盖更新于增量更新

覆盖更新和增量更新都是建立在在启用浏览器强制缓存策略的前提下的。增量更新是目前被业界广泛使用的前端静态资源更新策略，普遍的实现方案是通过为文件名添加hash指纹。覆盖更新缺陷多且没有较好的解决方案，目前已被逐渐淘汰。

覆盖更新：

    <link rel="stylesheet" href="main.home.css">
    // css添加新内容
    <link rel="stylesheet" href="main.home.css?v=8323d3829"> // 添加了hash值

将hash指纹作为url参数实现覆盖更新的方案有两个致命缺陷：

- 必须保证HTML文件与改动的静态文件同步更新，否则会出现资源不同步情况。对于依赖于服务端渲染的项目，目前大多数团队的部署方式是将网站的入口HTML和静态资源分开部署。这就意味着，两种资源上线具有时间差，这样就会导致用户访问页面的时候资源访问失败。
- 不利于版本回滚。由于覆盖更新每次迭代之后的资源都会覆盖服务器上原有的旧版本文件，这对于版本回滚不友好。

增量更新：

增量更新完美解决上述问题，实现方案是将原本作为参数的hash作为资源文件名的一部分并且删除用于更新的url参数。

    <link rel="stylesheet" href="main.home.8323d3829.css"> //增量更新

在静态资源使用增量更新的前提下，可以将静态资源先于动态HTML部署，此时静态资源没有引用入口，不会对线上环境产生影响；动态HTML部署后即可在第一时间访问已存的最新静态资源。

那么这部分的内容就介绍到这，希望大家能有所收获！