---
layout: post
title: 高级搜索树之B-树
date: 2018-05-18
tags: [ADT]
---

接下来会介绍一下高级搜索树B-树。

## B-树

### 动机

为了实现高效的I/O。系统存储容量的增长速度远小于应用问题规模的增长速度,相对来说应用的内存增长，内存是越来越小的。

<img src="http://os310ujuc.bkt.clouddn.com/avl48.png">

为什么不把内存做得更大呢？物理上，存储器越大，访问速度就越少，所以两者需要权衡利弊进行设计。

面对存储器的内在矛盾，采用高速缓存是一个普遍的解决方式。

- 不同容量的存储器，访问速度差异悬殊。例如磁盘和内存为例：ms / ns > 10 ^ 5,划算过来，就是一秒和一天的差距！若一次内存访问需要一秒，这一次外存访问就相当于一天。即：“天上方数日，人间已千年”;

所以，多数存储系统，都是分级组织的——caching，最常用的数据尽可能放在更高层，更小的存储器中是在找不到，才向更底层，更大的内存索取。

<img src="http://os310ujuc.bkt.clouddn.com/avl50.png">

相对于任何的存储级别，如果希望对上层级别和下层级别的写入或读写就叫I/O。对上层存储级别对下层存储级别的访问称之为外存访问。

- 从磁盘读写1B，与读写1KB几乎一样快。

批量式的访问：以页或块为单位，使用缓冲区。

### 结构

<img src="http://os310ujuc.bkt.clouddn.com/avl49.png">

这就是B树的典型结构，相对于典型的二叉查找树，B树更矮，更宽。B树也可以动态的变化。

### 多路平衡

与我们之前的二路搜索树来说，可通过适当的合并得到多路搜索树。超级节点，每个节点都可以拥有3个关键码，4个分支。

<img src="http://os310ujuc.bkt.clouddn.com/avl51.png">

多级存储系统中使用B树，可以针对外部查找，大大减少I/O次数。

这个对于AVL来说是不足的，例如，如果n=1G个记录，每次需要log(2, 10^9) = 30次I/O操作，每次只读出一个关键码，得不偿失。

对于B树，充分利用对批量访问的高校支持，将此特点转化为优点，没下降一层，都以超级节点为单位，读入一组关键码。具体来说，每组大小是磁盘的数据块大小而定m = @keys / pg，目前多数数据库系统采用m = 200 ~ 300.

回到原来场景，当m = 256的时候，则每次查找只需要log(256, 10 ^ 9) <= 4次I/O。

### 深度统一

所谓的m阶B树，即m路的平衡搜索树（m >= 2），外部节点的深度统一相等，所有叶节点的深度统一相等。树高h=外部节点的深度。

阶次m，内部节点各有不超过m-1个关键码，不超过m个分支。

内部节点的分支数n+1也不能太少，具体地，树根： 2 <= n + 1; 其余 [m / 2] <= n + 1;故称之为[m/2, m]树，例如（3,5）树，（3,6）树

### 紧凑表示

将每个引用都化作一个点，这样比较紧凑。a--b--c实心圆点为引用。

<img src="http://os310ujuc.bkt.clouddn.com/avl52.png">


### 实现

<img src="http://os310ujuc.bkt.clouddn.com/avl53.png">

一个超级节点可以在内部表示为向量，一个是关键码，一个是引用。

每个节点用于转向父亲的引用，一个向量放key，一份向量放引用。

## Btree接口定义

<img src="http://os310ujuc.bkt.clouddn.com/avl54.png">

核心是如何处理上溢和下溢。

### 查找

<img src="http://os310ujuc.bkt.clouddn.com/avl51.png">

对于Btree的查找，已知B树的词条极多，只能存放在外存，只需要载入必须的节点即可，可以尽量减少iO操作。已知每个key都是已经被存放在向量中。如果目标关键码存在这个树中，那么可以在这个新载入中的向量中进行顺序查找。命中，则可以返回。假如失败，必然会保留一个引用，指向下一层节点。然后再进行一次iO，直至返回的一个叶节点。最后还是需要进行一次目标关键码，加入失败，还可能通过引用指向下一个b树。

#### 实例

<img src="http://os310ujuc.bkt.clouddn.com/avl56.png">

一个3,5B树。假设查找75，第一次查找即可命中；假设查找69，第一次查找失败，通过引用，通过io读到下一层的节点并载入内存，然后通过一次顺序查找，找到69；

#### 算法实现

<img src="http://os310ujuc.bkt.clouddn.com/avl57.png">

e为目标关键码。V变为空的时候退出循环。

#### 主次成本

对B树的查找，依然是逐层深入，不断治之的过程。灰色线条为IO操作，时间消耗较多。对于向量内部的查找，每个节点内部为几百，二分查找比较低。高度h渐进logn。

#### 最大树高

含N个关键码的m阶B树，最大高度为logm(N)。第k层2 * [m / 2] ^ (k -1)，内部节点应该尽可能瘦。

树中n个关键码如果对应n个成功查找的可能，那么外部节点就是对应于n+1种失败的可能。

#### 最少高度

<img src="http://os310ujuc.bkt.clouddn.com/avl58.png">

同样，N个关键码的m阶B树，最小高度为logmN.当关键码总数量确定时，高度基本不变。