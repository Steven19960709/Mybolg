---
layout: post
title: 快排
date: 2018-05-28
tags: [ADT]
---

## 快速排序

快速排序是霍尔爵士在上世纪60年代发明的一种算法，也是分治策略的一种典型。

将序列分为两个序列，规定，前一个序列任何元素数值上都不能超过后一序列的任意元素。那么在子序列分别递归排序之后，原序列自然有序。

<img src="http://os310ujuc.bkt.clouddn.com/qs.png">

所以只需要完成左小右大的情况，剩下的即可让递归完成。

<img src="http://os310ujuc.bkt.clouddn.com/qs1.png">

轴点：pivot，是序列中的特殊元素，左/右侧的元素，均不比他更大/小。以轴点为界，原序列的划分自然实现：左小右大式的划分。只要找到轴点，即可快速调用递归来进行排序。

重点在partion的实现。

<img src="http://os310ujuc.bkt.clouddn.com/qs2.png">

但是原始序列中，轴点未必存在，而且quicksort必要条件是轴点必定依然定位。另外，对于乱序，在有序序列，所有元素结尾轴点。所谓的快排，就是将所有的元素，逐渐转化为轴点的过程。

### 构造轴点

先要选取一个轴点候选m（通常是序列的首元素），连个指针，将整个序列分为L和G和U，L都不大于m，G都不小于m，U是大小位置，初始位置下，U就是整个序列，lo向后移动，hi向前移动，每次移动，都会将元素放入U中，最后直到lo和hi指向同一个元素，将m替换该元素，那么，m就是轴点。

<img src="http://os310ujuc.bkt.clouddn.com/qs3.png">

### 不变形 单调性

两个子序列分别遵守跟U序列的大小关系，对于子序列U而言，其首元素和末元素都是交替的空闲单元。初始状态下，U的首元素被取出备份，因此可以看作空闲。不失一般性，lo为空闲。最后，U序列只剩下一个单元的时候。

<img src="http://os310ujuc.bkt.clouddn.com/qs4.png">

这里的待排序序列，初始序列为U，即整个序列，去首元素为轴点。于是开始拓展，先考察7,末元素，大于6，于是归入序列G，U减少一个，但是uU的拓展就止步于1，此时将1归入子序列L中，即转入到空闲单元，于是继续向右拓展，3也小于候选轴点，继续归入L。于是继续向右拓展，到8的时候，将8归入子序列G中，此时左侧恰好空闲，于是将8转入空闲单元，U减少一个单元，G拓展一个单元，并且腾出来的单元继续空闲。同样G的拓展，随后依次加入2 和 5a之后，G的拓展止步于9，随机将9转入末单元，最后到4的时候，将4转入首单元，最后将6放入空闲单元即可，随即找到轴点6.

<img src="http://os310ujuc.bkt.clouddn.com/qs5.png">


### 性能分析

这个算法不稳定。而且不能保证归并排序一样的时间复杂度为nlogn，跟首元素的选取有关。

<img src="http://os310ujuc.bkt.clouddn.com/qs6.png">

#### 平均情况

常规性能可以达到O(nlogn)，以均匀独立分布为例，调用partition算法，有几种可能，主要取决于候选轴点的选取。因为均匀分布，各种情况概率都是相等的。最后可以合并成一个调和级数，即与nlgn同阶的级数。

<img src="http://os310ujuc.bkt.clouddn.com/qs7.png">

### 变种

#### 不变性

新算法的原理如下图，有四个部分，分别为四个字序列。现在序列顺序变为LGU，而不是原来的LUG。中间有四个界定值，lo，mi，k，hi。

<img src="http://os310ujuc.bkt.clouddn.com/qs8.png">

#### 单调性

同样的，这个新方法需要利用反复迭代来进行。在每一步迭代中，都是考虑子序列U中的首元素，即k指向的x，根据x大小来将它归入G或者L中。

如果后选元素不小于候选轴点，那么直接对G进行拓展，即将x加入到G中，这个时候，L保持不变，代码实现，经过一次比较，如果符合这种情况，让k
递减一个单位，让他指向后一个单位。如果后选元素大于候选轴点，将x归入子序列L中，但是此时L不能扩展，这个时候，需要将G向后移动一个单元，相当于腾出一个空间，于是将x归入，但是考虑到效率问题，这种方法通常不会使用，我们可以使用滚动方式，只需将G的首元素归到末元素即可，即将mi+1,移到后面，将x移到前面。终止的最后一步就是使用将候选轴点移到L和G的交界处，G保持不动，L的末元素替换为候选轴点即可。

<img src="http://os310ujuc.bkt.clouddn.com/qs9.png">

#### 实现

依然将首元素作为候选轴点，接下来是一个循环，如果当前的元素k，比候选节点小，则与mi进行交换，并且，L向右扩展，k向右平移一个单位，for循环的更新环节，合并了一个操作，即k的向右平移。在算法的入口处，随机的选取一个元素，与首元素交换，这样可以优化算法，减少出现最坏情况的概率。

<img src="http://os310ujuc.bkt.clouddn.com/qs10.png">

#### 实例

11个元素构成的序列，首先将6作为候选轴点，整体元素构成U，L和G此时为空。3首先归入L，对应if分支，此后8a，利用k++U缩短一个单位，子序列拥有第一个元素。接下来是1，此时，它比候选轴点要小，这个时候8a与1进行交换（子序列L向后移动一个单位，G序列的8a滚动移动一个单位），对于5a，与8a进行交换，L向后拓展一个单位，G右后移一个单位；对于9，对应的是else分支，归入G序列；对于8b，同样地对应else分支，简明地令k++，向后拓展一个单位。接着是4，归入L中，8a进行滚动平移，5b归入L序列。8b进行滚动平移。最后直至U序列为空，零候选轴点归位（与L的末元素2互换位置）。

<img src="http://os310ujuc.bkt.clouddn.com/qs11.png">

#### 时间空间稳定

总体的partition算法为线性的时间，对于稳定性，重复元素的次序可以保存。对于子序列G，会导致不稳定性，因为其进行了滚动平移，例如8a和8b，就调转了两个相对的位置。

### 选取元素

Selection，现在我们可以对排序计算进行应用，例如寻找众数。

k-selection：在任意一组可比较大小的元素中，从小到大找到次序为k的元素。

<img src="http://os310ujuc.bkt.clouddn.com/qs12.png">

#### 众数

无序向量中，若有一半以上元索同为m，则称之为众数。

必要性：若存在众数，则概述必为中位数（只有中位数才可能是众数的唯一候选），可以通过遍历和统计来验证是否为众数。

<img src="http://os310ujuc.bkt.clouddn.com/qs13.png">

频繁数：出现次数最多的数。众数若存在，则必然为频繁数。

<img src="http://os310ujuc.bkt.clouddn.com/qs14.png">

#### 减而治之

利用减而治之，从问题的规模是不断缩小中暑的求解范围。约定所有的元素都是按照随机无序安放在向量A中，希望能够依照某种准则，在A中减除某个前缀P，从而将A中选取众数的问题减去为在P中寻去众数的问题。A-P序列的众数构成了A的众数的必要情况。

<img src="http://os310ujuc.bkt.clouddn.com/qs15.png">

算法：反复迭代进行，每次都可以在A中减去一个前缀P，不断循环，最后到平凡情况出现。首元素设为x，不断统计x的数量，知道x在P中占据一半的数量。

根据maj来选取众数候选者，c为计算器，初值为0，循环便利向量，如果相等元素则+1，否则-1.响应地更新差额计算器。当这个计算值都以便利过后，maj则为众数候选者。

<img src="http://os310ujuc.bkt.clouddn.com/qs16.png">

### 通用算法

针对一般性的选取问题，介绍一下优化的通用算法。寻找秩为k的元素。

最直接的方法就是直接将数据集进行一次排序。然后从首元素开始，一次向后移动，当移动k次之后，需找到值为k的数。但是这个方法需要做一次排序，至少要花费O(nlogn)的性能。

尝试：堆（A）

<img src="http://os310ujuc.bkt.clouddn.com/qs17.png">

利用getMax()，来进行高效的选取操作。首先将所有元素组成一个堆，对顶元素是全局的最小值，每次调用delMin()即可摘除最小元，秩为0的元素，下次为秩为1的元素，调用k次之后为n-k。对于建堆操作，调用弗洛伊德算法，只需要线性的时间，但是接下来每次都需要O(k*logn)累计时间来对delMin接口调用消耗，与全排序无实质区别。

尝试：堆（B）

将元素组织为大顶堆。

<img src="http://os310ujuc.bkt.clouddn.com/qs18.png">

当所有元素都被处理之后，对顶元素也就是全局秩为k的元素。但是时间复杂度仍然不能够得到有效地控制。无论插入还是删除达到O(2*(n-k)*logk)

尝试：堆（C）

将使用两个堆来进行操作。只要h>g,即令两个元素交换位置，直至g不大于h。

<img src="http://os310ujuc.bkt.clouddn.com/qs19.png">

但是，同样时间复杂度不令人满意。

#### quickSelect

使用减而治之的方法，快排中的partition算法，将当前序列中构造出一个轴点。针对最好的情况，有可能候选轴点即为k选取问题中的秩为k的元素，那么最后只要一次partition即可，利用这个方法可以使范围得到裁减。

如图，如果对应的i不是需要的目标k，那么，如果轴点的秩，可以判断是否需要将L或者G减除掉，如果k是大于i的，表示k在G中，否则可能在L中，无论什么情况，都是可以将范围一步一步缩减，迟早可以找到目标元素。反复迭代，减而治之。

<img src="http://os310ujuc.bkt.clouddn.com/qs20.png">

但是，这个算法仍然不能达到理想的效率。内循环尽管每次只需要线性的时间，但是外循环在最坏情况下，需要执行多大n次。

<img src="http://os310ujuc.bkt.clouddn.com/qs21.png">

#### linearSelect()

对quickselect进行改造，需要用到常数Q，采用递归进行解决，称为linearSelect。

<img src="http://os310ujuc.bkt.clouddn.com/qs22.png">

首先要准备好递归基，当问题规模足够小时，可以采用平凡的选取算法。将问题均匀的分为若干组，每组都是随机的序列。接下来对于每个这样的子序列进行排序，这里不用在意效率。排序完成可以得到序列的中位数，总共有Q个中位数，然后找到中位数的中位数,即为M。（通过递归，即linearSelect算法本身）在接下来，以该中位数机型分类。

k，可能在L，或者E，或者G中，无论如何，都可以排除掉其他两个序列。

对于E序列，这意味着，全局的中位数即为查找对象。随即返回。

##### 复杂度

将linearSelect算法运行时间记作T(n)，

- 第0步：O(1) = O(QlogQ) // 递归基：序列长度
- 第1步：O(n) // 子序列划分
- 第2步：O(n)  // 子序列格子排序，并找到中位数
- 第3步：T(n/Q) // 从n/Q个中位数中，递归地找到全局中位数
- 第4步：O(n) // 划分子级L/#/G,并分别计数，一趟扫描即可
- 第5步：T(3n/4)

对于第五步，问题的规模可以削减为原来的75%.在某种意义上，如上确定的M必然不偏不倚，至少各有n/4各元素，不小于/不大于M。

<img src="http://os310ujuc.bkt.clouddn.com/qs23.png">

最后，linearSelect复杂度：

    T(n) = O(n) + T(n/Q) + T(3n/4) 

为了使之解作线性函数，只需保证：n/Q + 3n/4 < n,或者等价地1/Q + 3/4 < 1'

例如Q=5，则存在常数C，使得

    T(n) = Cn + T(n/5) + T(3n/4) 

### 希尔排序Shell序

将整个序列视为一个矩阵，逐列各自排序w-sorting。每次shellsort过程，都是有若干个w-sorting构成的。

递减增量：由粗到细，重拍矩阵，使其更窄，再次逐列排序。如此往复，直至举证变成一列。

<img src="http://os310ujuc.bkt.clouddn.com/qs24.png">

采用不同的步长序列，性能不尽相同。首项w1等于1.无论如何，最后都需要进行一次one-sorting。

#### 实例

##### w = 8

<img src="http://os310ujuc.bkt.clouddn.com/qs25.png">

13个整数的排序序列，按照不超过8个序列进行划分。然后对矩阵进行逐列排序。最后的三列直接得到排序结果。

最后，将序列的每一行逐个取出，并依次串接。最后成为一个新的线性序列。

##### w = 5

<img src="http://os310ujuc.bkt.clouddn.com/qs26.png">

这个是以5为宽度的矩阵。

##### w = 3

<img src="http://os310ujuc.bkt.clouddn.com/qs27.png">

宽度为3的矩阵。

##### w = 2

<img src="http://os310ujuc.bkt.clouddn.com/qs28.png">

不难发现，每次逐列排序下来，整个序列的有序性都是在改善的。

最后对w=1在进行一次排序即可。

<img src="http://os310ujuc.bkt.clouddn.com/qs29.png">

#### 寻秩访问

<img src="http://os310ujuc.bkt.clouddn.com/qs30.png">

实现矩阵的重排，如果是一维向量的输入，直接在原来的向量进行操作即可。对于特定宽度的矩阵，都可以通过计算得到。物理上还是一维向量，但是逻辑上可以理解为二维的。（寻秩访问的特性）

关于内部的排序，只需要具有输入敏感性即可，即随着序列有序性不断改善，计算成本会递减，可以保证总体计算成本足够低廉。可以使用插入排序（逆序对情况），取决于输入序列的指标。

影响更大的，将取决于使用何种步长序列。考虑比较操作，移动操作的次数，收敛速度，迭代轮数。在数据量非常大时，可能会引发相应的IO，那么迭代次数将是敏感因素。

##### shell序列

步长序列使用shell序列每一项都是前一项的两倍，最坏情况下，将会导致n^2量级的时间复杂度。

<img src="http://os310ujuc.bkt.clouddn.com/qs31.png">

每一轮的排序都浪费大量时间在处理逆序对中。为此，应尽量地让相邻的元素互素。

#### 逆序对

引入h-sorting和h-ordered，如果任意序列，可以任何一对以h为间隔，保证前小后大的序列。称之为h-ordered。任何一个序列只要做一次h-sorting之后必然是h-ordered。

<img src="http://os310ujuc.bkt.clouddn.com/qs32.png">

如果一个序列是h-ordered 也是g-ordered，希尔排序中，对应的矩阵宽度都会相应减少。

任何一个已经是g-ordered的序列，在h-sorting之后，都是h-ordered。

如果及时g-orered也是h-ordered，称为(g,h)-ordered。

<img src="http://os310ujuc.bkt.clouddn.com/qs33.png">

插入排序具有输入敏感性，所以希尔排序底层使用插入排序。