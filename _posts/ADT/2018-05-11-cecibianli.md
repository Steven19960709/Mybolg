---
layout: post
title: 层次遍历与二叉树重构
tags: [ADT]
date: 2018-05-11
---

之前讨论的都是有根有序树，于是就可以在垂直方向，按照树的深度划分统一等价类。那么对于同辈节点，应该怎样确定次序呢？对于二叉树，可以根据水平方向左右顺序来确定。

对于先序遍历，中序遍历，后序遍历，都出现了子代先于父级接受访问，那么对于层次遍历，严格遵守，层次的顺序进行遍历。这时候，栈的对称结构队列就有很大用处了。

### 层次遍历

    template <typaname T> template <typename VST>
    void BinNode<T> :: travLevel(VST & visit) {//二叉树层次遍历
        Queue<BinNodePosi(T)> Q; // 引入辅助队列
        Q.enqueue(this); //根节点入队
        while( !Q.empty() ) {//在队列再次变空之前，反复迭代
            BinNodePosi(T) x = Q.dequeue(); //取出首节点，并随即
            visit( x -> data ); //访问之
            if (HasLChild(*x)) Q.enqueue(x->lChild); //左孩子入队
            if (HasRChild(*x)) Q.enqueue(x->rChild); //右孩子入队
        }
    }

循环中，每次都取出队首节点，然后随机访问他，如果有左孩子，左孩子入队，如果有右孩子，右孩子入队，做完之后进入下一步迭代。只有当队列重新变空时，算法终止。

### 实例

<img src="http://os310ujuc.bkt.clouddn.com/cengcibianli1.png">

A先入队，之后通过循环，取出节点A，访问它，之后访问其左孩子，令B入队，然后队首节点dequeue，访问其左节点，C先入队，然后D入队。（队列先进先出，不用像之前的先序遍历，将左右入栈顺序颠倒）然后C出队，无左右孩子。进入下一个迭代，D出队，左顾右盼，发现，左右孩子都存在，于是令E，F入队。然后在进入下一步迭代，E出队，访问E，G入队。然后F出队，访问F，无左右孩子。最后G出队。最后队列变空，意味着输的层次遍历完成。

### 二叉树的重构

任何一个二叉树都能抽象出三种遍历策略，先中后。如果一直某棵树的遍历序列，如何还原一棵树的拓补结构？

#### 先/后序遍历 + 中序遍历

根据先序遍历序列，可以确定数根节点，然后根据中序遍历，可以确定左子树和右子树分别是那些节点组成的。

但是，无论是左子树还是右子树，规模都是可能是0.只根据先序遍历和后续遍历序列不能对树进行重构，因为有可能是空树。

#### [先序 + 后序 ] x 真二叉树

真二叉树，即子树是偶数，非零则二。

先序遍历首先出现根节点，然后是左节点，然后是右节点。

后序遍历根节点收尾，然后是右节点收尾，最后是左节点。

<img src="http://os310ujuc.bkt.clouddn.com/chonggou.png">

可以确定左子树是有什么节点构成，右子树是有什么节点构成。

最后再复习几个概念：

- 完全二叉树：即叶节点只能出现在最底部得两层，而且，最底层叶节点均处于次底层叶节点的左侧。

- 满二叉树：所有叶节点同处于低层，每一层的节点树都达到饱和。高度为h的满二叉树由 2^(h+1) - 1个节点构成，叶节点数总是恰好比内部结点多出一个，例如：n=15个节点，高度h=3的满二叉树，其中叶节点8个，内部节点7个。