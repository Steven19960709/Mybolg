---
layout: post
title: 串
date: 2018-05-26
tags: [ADT]
---

## 串

所谓字符串，即由字符表中来的每个字符由前到后组成的串，按照线性次序。串的实现可以通过向量或者列表来实现。

组成字符串的字符种类不多，但是串长往往远大于字符种类。

### 术语

字符串S，由n个字符串构成，记作:
    
    S[0,n) = T[0,m)
    
对应的字符均相同。

- 子串：S.substr(i,k) = S[i, i+k), 0 <= i < n, 0 <= k;

<img src="http://os310ujuc.bkt.clouddn.com/ser.png">

注意的是，空串长度为0，规定空串是任何串的前缀和后缀。

串提供的功能接口：

<img src="http://os310ujuc.bkt.clouddn.com/ser2.png">

其中indexOf实现为主要的内容。

### 串匹配

grep，Linux中可以查找特定字符串的指令。

    % grep <pattern> <text> 
    文本 T 
    模式 P

Pattern matching：

- detection：P是否出现
- location：首次出现位置
- counting：共有几次出现
- enumeration：各出现的位置

### 算法测评

客观地测量与评估串匹配的性能。通过随机T,对成功，失败的匹配分别测试

- 成功：在T中，随机取出长度为m的子串作为P,分析平均复杂度
- 失败：采用随机的P，统计平均复杂度

#### 蛮力匹配

从最简单的方法开始。所谓匹配成功，简单理解，即位置对齐。我们可以核对每个位置，自左向右，以单个字符为间隔，一次移动模式串和文本串进行匹配。

<img src="http://os310ujuc.bkt.clouddn.com/ser1.png">

一旦所以字符对齐，即匹配成功。

##### 实现

- 版本1：

每个结尾会有哨兵，i，j分别模版串和实例串的当前位置。比对过程是while循环中实现的。

在算法任何位置，i和j确定指针的位置。i越界的时候， 有：
    
    i = n,
    j < m,
    i - j > n - m

return i - j,表明究竟成功还是失败。

<img src="http://os310ujuc.bkt.clouddn.com/ser3.png">

- 版本2

这里的i和j指代不一样。每次匹配串中，对齐位置都是由i决定的。

<img src="http://os310ujuc.bkt.clouddn.com/ser4.png">

##### 复杂度

最好情况第一个位置，一轮比对即可成功。最坏情况，需要尝试所有对齐位置。字母表越小，最坏情况出现概率越高，m越大，最坏情况后果更严重。但是，当字母表很大，漫里算法能达到O(n)

<img src="http://os310ujuc.bkt.clouddn.com/ser5.png">
<img src="http://os310ujuc.bkt.clouddn.com/ser6.png">

#### KMP算法

之前的蛮力匹配低效的原因，匹配的过程中，多次各字符可能会多次匹配到，最多可达m次。其中，很多都是无需匹配多次，从此产生效率的消耗。

当我们匹配到某前缀相等的时候，就可以把匹配到前缀的信息保存下来，利用这些信息，可以大量的排除对齐位置，不必再一次一次比对。（记忆力）

我们可以利用记忆力转化为预知力，高效利用之前的匹配结果，多次向右移动子串。

<img src="http://os310ujuc.bkt.clouddn.com/ser7.png">

直接从保存的信息获取到R，从R开始匹配。

##### KMP算法：查询表

KMP算法的高效，无非就是构造出一张查询表。

<img src="http://os310ujuc.bkt.clouddn.com/ser8.png">

##### 实现

<img src="http://os310ujuc.bkt.clouddn.com/ser9.png">

首先构造出查询表（next 表），接下来需要两个整数，非别指向模式串和文本串的字符。while循环也类似，主要区别在else，适配情况，只要在next中取出j，并且替换之前的j。

##### 实例

<img src="http://os310ujuc.bkt.clouddn.com/ser10.png">

直接跳过不需要匹配的字符。

#### 原理

KMP算法借助必要条件，跳过不需要匹配的字符。

<img src="http://os310ujuc.bkt.clouddn.com/ser11.png">

过程：快速右移，如图，在T[i]与P[j]发现了一次失配，接下来KMP会查询next表，取出表项t，并用P[t]来取代此前的P[j]，使之与之前的T[i]相对齐。并从i出发，继续后续的比对。KMP为什么会选择t呢？条件是啥？

如图所示，对于t所对应的前缀，这个前缀不会接受重复的比对，因为KMP已经预先判定，这个前缀必然会与主串中的这个子串完全匹配。

在此前的前缀中，必须要有长度为t的后缀长度相等，手部和尾部必须有一定的相似性。即相对于P[j]而言，其首部和尾部必须具有一定的相似性。

如果用t取代原来的j，那么位移差就是j-t，j是固定的t越小，相对位移越大。t最大，相对位移就越小，位移量小，意味着更安全——避免回溯。KMP所选取的，就是最大的t。

#### 通配哨兵

这里的候选者集合N(p,j)，只要j是正数，那么必然包含0。对于空集，真前缀和真后缀都是不存在的。为每一个模式串的前端增设一哨兵，这个哨兵与任意字符都匹配。当匹配失败，哨兵会与对应位置的模板进行匹配。

使用哨兵，可以使代码更简洁，容易理解。

### 构造next表

next表的构造过程，在KMP主算法本质上是完全一样的。

根据已知的next[0, j], 如何高效计算next[j + 1]？

next表的定义，其实，所谓的next(j),即是在P[0,j]（模式项）中，最大自匹配的真前缀和真后缀的长度。

所以next[j + 1] 最多增长一个单位：

    next[j + 1] <= next[j] + 1;
    当且仅当P[j] == P[next[j]]时取等号

<img src="http://os310ujuc.bkt.clouddn.com/ser12.png">

只要P[j]与它的继任者是相等的，那么可以简明地通过加1得到下一项，即使不相等，也可以这个必要条件依然可以使用，也就是说，在这种情况下如果有估算出next表的j+1项，下一个值得尝试的位置，依然需要满足自相似的必要条件。

那么对应的前缀的长度，就是此前长度的基础上再去一次next表项。所以就有P[0 ,n(n(j))]这样的表示。

概括而言，估算next表下一项的过程中应该按照右边的序列尝试。对于任意一个j而言，其对应的next表项都会严格地小于j自身，所有序列严格递减。

<img src="http://os310ujuc.bkt.clouddn.com/ser13.png">

纵观整个过程，实质上就是模式串自己对自己的匹配过程。

实现：

<img src="http://os310ujuc.bkt.clouddn.com/ser14.png">

入口参数只有模式串自己，所以P即使模式串，也是文本串。然后是初始化。while循环里面的if和else分别对应匹配和适配的情况。

假设，递推计算出下一项，此时我们的P[j]是这个x，首先尝试的是next[j]，如果对应的字符与P[j]不等，也就是对应于循环中的else分支，于是，将next[j]进而替换为next[next[j]],并且继续用对应的这个字符P[j]进行比对，如果依然不等，就需要将next[next[j]]进一步地替换为next[next[next[j]]]，在任何一步迭代中，一旦当前的字符P[j]相等，就可以立即将下一个next表项设置为在这个前缀的长度基础上，在累进一个单位。

#### 复杂度

KMP算法可以根据对齐位置分为若干阶段，为了准确评估，应该将计算成本分摊的每个阶段。即便在最坏情况下，不会超过线性。即O(n)。

整个迭代步数不会超过K。渐进意义上K不会超过线性范围。

<img src="http://os310ujuc.bkt.clouddn.com/ser15.png">