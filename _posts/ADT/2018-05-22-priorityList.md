---
layout: post
title: 优先级队列
date: 2018-05-22
tags: [ADT]
---

## 优先级队列

优先级队列，不再是按照先入先出，或者先进后出，而是按照优先级来进行出队。

每个队列的对象都有一个优先级，不是寻秩访问，寻值访问，寻关键码访问，而是寻优先级访问，call-by-priority。

需要实现的功能接口如下：

<img src="http://os310ujuc.bkt.clouddn.com/pri.png">

### 基本实现

考虑成本和效率。

对于向量，将所有元素组织成一个向量，通过向量的insert即可插入。

<img src="http://os310ujuc.bkt.clouddn.com/pri1.png">

但是复杂度高，insert的时候需要重新遍历整个向量。

如果对于有序向量，也是不可行的，因为维护成本过高，例如查找的时候需要二分logn。

列表同样都是不合适，插入操作需要O(n)。

最后自然考虑使用BBST，三个接口只需O(logn)时间。但是这个对于成本这一项太大了。BBST始终维持所由元素的全序关系，我们只需要维护偏序关系即可。

#### 完全二叉树

<img src="http://os310ujuc.bkt.clouddn.com/pri3.png">

complete Binary tree平衡因子处处非负，是AVL树的特例。

对于结构性，向量等价与完全二叉树，物理上可以直接借助向量实现。完全二叉树的节点和向量中的节点都是一一对应的。这样可以得到向量中父子节点的关系。

例如，以节点11为例，它的父节点可以表示为（11 - 1）/2，对于6的左孩子（1 + 6 * 2）为13.因为这种结构借助了完全二叉树，那么称之为完全二叉堆。

通过继承来作为完全二叉堆（完全二叉树+向量）

<img src="http://os310ujuc.bkt.clouddn.com/pri4.png">

### 堆序性

在完全二叉堆中简历顺序性。数值上，只要 0 < i，必然满足:

    H[i] <= H[Parent(i)]

所以H[0]是全局最大元素。

### 插入和上滤

为插入词条e，只需将e作为末元素接入向量。等价于在完全二叉树末端接入一个节点。可以让结构性自然保持，堆序性却未必可以延续，需要考虑其与父亲节点的关系，是否需要互换位置,不断重复知道e满足堆序性（e每次上升一层）

<img src="http://os310ujuc.bkt.clouddn.com/pri5.png">

#### 实现

<img src="http://os310ujuc.bkt.clouddn.com/pri6.png">

首先将带插入的词条插入到向量之中，秩为n-1,调用percolateUp算法，实行上滤。

#### 效率

在每次交换之前做一次缓存，对比的时候，当发现不合适，在进行上滤。